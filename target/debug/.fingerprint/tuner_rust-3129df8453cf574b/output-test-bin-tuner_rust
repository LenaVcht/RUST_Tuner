{"$message_type":"diagnostic","message":"cannot find value `octave` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/gui.rs","byte_start":11868,"byte_end":11874,"line_start":292,"line_end":292,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let midi_note = (octave + 1) * 12 + note_index as i32;","highlight_start":22,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `octave` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gui.rs:292:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m292\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let midi_note = (octave + 1) * 12 + note_index as i32;\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Instant`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":122,"byte_end":129,"line_start":5,"line_end":5,"column_start":27,"column_end":34,"is_primary":true,"text":[{"text":"use std::time::{Duration, Instant};","highlight_start":27,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":120,"byte_end":129,"line_start":5,"line_end":5,"column_start":25,"column_end":34,"is_primary":true,"text":[{"text":"use std::time::{Duration, Instant};","highlight_start":25,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":111,"byte_end":112,"line_start":5,"line_end":5,"column_start":16,"column_end":17,"is_primary":true,"text":[{"text":"use std::time::{Duration, Instant};","highlight_start":16,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":129,"byte_end":130,"line_start":5,"line_end":5,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"use std::time::{Duration, Instant};","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Instant`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:5:27\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::time::{Duration, Instant};\n  \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"no method named `polygon` found for reference `&eframe::egui::Painter` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gui.rs","byte_start":4828,"byte_end":4836,"line_start":122,"line_end":122,"column_start":17,"column_end":25,"is_primary":false,"text":[{"text":"                painter.polygon(","highlight_start":17,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":4836,"byte_end":4843,"line_start":122,"line_end":122,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                painter.polygon(","highlight_start":25,"highlight_end":32}],"label":"method not found in `&eframe::egui::Painter`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `polygon` found for reference `&eframe::egui::Painter` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gui.rs:122:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 painter.polygon(\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m--------\u001b[0m\u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&eframe::egui::Painter`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `none` found for struct `Stroke` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gui.rs","byte_start":5208,"byte_end":5212,"line_start":129,"line_end":129,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"                    egui::Stroke::none(),","highlight_start":35,"highlight_end":39}],"label":"function or associated item not found in `Stroke`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Stroke`, consider using `Stroke::new` which returns `Stroke`","code":null,"level":"note","spans":[{"file_name":"/Users/nadinemueller/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/epaint-0.27.2/src/stroke.rs","byte_start":604,"byte_end":672,"line_start":23,"line_end":23,"column_start":5,"column_end":73,"is_primary":true,"text":[{"text":"    pub fn new(width: impl Into<f32>, color: impl Into<Color32>) -> Self {","highlight_start":5,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `ne` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/nadinemueller/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs","byte_start":9828,"byte_end":9861,"line_start":264,"line_end":264,"column_start":5,"column_end":38,"is_primary":true,"text":[{"text":"    fn ne(&self, other: &Rhs) -> bool {","highlight_start":5,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `none` found for struct `Stroke` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gui.rs:129:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     egui::Stroke::none(),\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `Stroke`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `Stroke`, consider using `Stroke::new` which returns `Stroke`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/nadinemueller/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/epaint-0.27.2/src/stroke.rs:23:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(width: impl Into<f32>, color: impl Into<Color32>) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `ne` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/nadinemueller/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m264\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn ne(&self, other: &Rhs) -> bool {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/gui.rs","byte_start":9815,"byte_end":9880,"line_start":237,"line_end":237,"column_start":25,"column_end":90,"is_primary":true,"text":[{"text":"                        self.update_pitch(Some(placeholder_freq), max_amplitude.min(1.0));","highlight_start":25,"highlight_end":90}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":8691,"byte_end":8710,"line_start":215,"line_end":215,"column_start":36,"column_end":55,"is_primary":false,"text":[{"text":"        if let Some(samples_arc) = &self.audio_samples {","highlight_start":36,"highlight_end":55}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":8746,"byte_end":8764,"line_start":216,"line_end":216,"column_start":34,"column_end":52,"is_primary":false,"text":[{"text":"            if let Ok(samples) = samples_arc.lock() {","highlight_start":34,"highlight_end":52}],"label":"a temporary with access to the immutable borrow is created here ...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":10092,"byte_end":10093,"line_start":244,"line_end":244,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            }","highlight_start":13,"highlight_end":14}],"label":"... and the immutable borrow might be used here, when that temporary is dropped and runs the destructor for type `Result<std::sync::MutexGuard<'_, std::vec::Vec<f32>>, PoisonError<std::sync::MutexGuard<'_, std::vec::Vec<f32>>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable because it is also borrowed as immutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gui.rs:237:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(samples_arc) = &self.audio_samples {\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[94m-------------------\u001b[0m \u001b[1m\u001b[94mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m216\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Ok(samples) = samples_arc.lock() {\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94ma temporary with access to the immutable borrow is created here ...\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m237\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         self.update_pitch(Some(placeholder_freq), max_amplitude.min(1.0));\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m244\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             }\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94m... and the immutable borrow might be used here, when that temporary is dropped and runs the destructor for type `Result<std::sync::MutexGuard<'_, std::vec::Vec<f32>>, PoisonError<std::sync::MutexGuard<'_, std::vec::Vec<f32>>>>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/gui.rs","byte_start":9935,"byte_end":9963,"line_start":239,"line_end":239,"column_start":25,"column_end":53,"is_primary":true,"text":[{"text":"                        self.update_pitch(None, 0.0);","highlight_start":25,"highlight_end":53}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":8691,"byte_end":8710,"line_start":215,"line_end":215,"column_start":36,"column_end":55,"is_primary":false,"text":[{"text":"        if let Some(samples_arc) = &self.audio_samples {","highlight_start":36,"highlight_end":55}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":8746,"byte_end":8764,"line_start":216,"line_end":216,"column_start":34,"column_end":52,"is_primary":false,"text":[{"text":"            if let Ok(samples) = samples_arc.lock() {","highlight_start":34,"highlight_end":52}],"label":"a temporary with access to the immutable borrow is created here ...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":10092,"byte_end":10093,"line_start":244,"line_end":244,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            }","highlight_start":13,"highlight_end":14}],"label":"... and the immutable borrow might be used here, when that temporary is dropped and runs the destructor for type `Result<std::sync::MutexGuard<'_, std::vec::Vec<f32>>, PoisonError<std::sync::MutexGuard<'_, std::vec::Vec<f32>>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable because it is also borrowed as immutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gui.rs:239:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(samples_arc) = &self.audio_samples {\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[94m-------------------\u001b[0m \u001b[1m\u001b[94mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m216\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Ok(samples) = samples_arc.lock() {\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94ma temporary with access to the immutable borrow is created here ...\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m239\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         self.update_pitch(None, 0.0);\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m244\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             }\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94m... and the immutable borrow might be used here, when that temporary is dropped and runs the destructor for type `Result<std::sync::MutexGuard<'_, std::vec::Vec<f32>>, PoisonError<std::sync::MutexGuard<'_, std::vec::Vec<f32>>>>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/gui.rs","byte_start":10032,"byte_end":10060,"line_start":242,"line_end":242,"column_start":21,"column_end":49,"is_primary":true,"text":[{"text":"                    self.update_pitch(None, 0.0);","highlight_start":21,"highlight_end":49}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":8691,"byte_end":8710,"line_start":215,"line_end":215,"column_start":36,"column_end":55,"is_primary":false,"text":[{"text":"        if let Some(samples_arc) = &self.audio_samples {","highlight_start":36,"highlight_end":55}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":8746,"byte_end":8764,"line_start":216,"line_end":216,"column_start":34,"column_end":52,"is_primary":false,"text":[{"text":"            if let Ok(samples) = samples_arc.lock() {","highlight_start":34,"highlight_end":52}],"label":"a temporary with access to the immutable borrow is created here ...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gui.rs","byte_start":10092,"byte_end":10093,"line_start":244,"line_end":244,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            }","highlight_start":13,"highlight_end":14}],"label":"... and the immutable borrow might be used here, when that temporary is dropped and runs the destructor for type `Result<std::sync::MutexGuard<'_, std::vec::Vec<f32>>, PoisonError<std::sync::MutexGuard<'_, std::vec::Vec<f32>>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable because it is also borrowed as immutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gui.rs:242:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m215\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(samples_arc) = &self.audio_samples {\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[94m-------------------\u001b[0m \u001b[1m\u001b[94mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m216\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Ok(samples) = samples_arc.lock() {\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94ma temporary with access to the immutable borrow is created here ...\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m242\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.update_pitch(None, 0.0);\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m243\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 }\n\u001b[1m\u001b[94m244\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             }\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94m... and the immutable borrow might be used here, when that temporary is dropped and runs the destructor for type `Result<std::sync::MutexGuard<'_, std::vec::Vec<f32>>, PoisonError<std::sync::MutexGuard<'_, std::vec::Vec<f32>>>>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `samples` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1873,"byte_end":1880,"line_start":45,"line_end":45,"column_start":50,"column_end":57,"is_primary":true,"text":[{"text":"                                samples.drain(0..samples.len() - max_samples);","highlight_start":50,"highlight_end":57}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1856,"byte_end":1863,"line_start":45,"line_end":45,"column_start":33,"column_end":40,"is_primary":false,"text":[{"text":"                                samples.drain(0..samples.len() - max_samples);","highlight_start":33,"highlight_end":40}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1864,"byte_end":1869,"line_start":45,"line_end":45,"column_start":41,"column_end":46,"is_primary":false,"text":[{"text":"                                samples.drain(0..samples.len() - max_samples);","highlight_start":41,"highlight_end":46}],"label":"mutable borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `samples` as immutable because it is also borrowed as mutable\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:45:50\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   samples.drain(0..samples.len() - max_samples);\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94m-----\u001b[0m    \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94mmutable borrow later used by call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `config`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1321,"byte_end":1327,"line_start":37,"line_end":37,"column_start":29,"column_end":35,"is_primary":false,"text":[{"text":"                    &config.into(),","highlight_start":29,"highlight_end":35}],"label":"`config` moved due to this method call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1726,"byte_end":1732,"line_start":43,"line_end":43,"column_start":47,"column_end":53,"is_primary":false,"text":[{"text":"                            let max_samples = config.sample_rate().0 as usize * 2;","highlight_start":47,"highlight_end":53}],"label":"use occurs due to use in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1349,"byte_end":1397,"line_start":38,"line_end":38,"column_start":21,"column_end":69,"is_primary":true,"text":[{"text":"                    move |data: &[f32], _: &cpal::InputCallbackInfo| {","highlight_start":21,"highlight_end":69}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":953,"byte_end":959,"line_start":29,"line_end":29,"column_start":13,"column_end":19,"is_primary":false,"text":[{"text":"        let config = device.default_input_config()","highlight_start":13,"highlight_end":19}],"label":"move occurs because `config` has type `SupportedStreamConfig`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`into` takes ownership of the receiver `self`, which moves `config`","code":null,"level":"note","spans":[{"file_name":"/Users/nadinemueller/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/convert/mod.rs","byte_start":16892,"byte_end":16896,"line_start":455,"line_end":455,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"    fn into(self) -> T;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can `clone` the value and consume it, but this might not be your desired behavior","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1320,"byte_end":1320,"line_start":37,"line_end":37,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"                    &config.into(),","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: use of moved value: `config`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:38:21\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let config = device.default_input_config()\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mmove occurs because `config` has type `SupportedStreamConfig`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     &config.into(),\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94m`config` moved due to this method call\u001b[0m\n \u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     move |data: &[f32], _: &cpal::InputCallbackInfo| {\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                             let max_samples = config.sample_rate().0 as usize * 2;\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94muse occurs due to use in closure\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `into` takes ownership of the receiver `self`, which moves `config`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/nadinemueller/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/convert/mod.rs:455:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m455\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn into(self) -> T;\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can `clone` the value and consume it, but this might not be your desired behavior\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    &config\u001b[92m.clone()\u001b[0m.into(),\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 8 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 8 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0382, E0425, E0502, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0382, E0425, E0502, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0382`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0382`.\u001b[0m\n"}
